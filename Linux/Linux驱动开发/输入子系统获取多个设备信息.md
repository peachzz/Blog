
----------
4/8/2020 5:20:34 PM 
#### 输入子系统获取多个设备信息 ####
----------


```
//simple_input_drv.c
#include <linux/init.h>
#include <linux/module.h>
#include <linux/input.h>
#include <linux/interrupt.h>
#include <linux/of.h>
#include <linux/of_irq.h>
#include <linux/of_gpio.h>
#include <linux/of_address.h>
#include <linux/platform_device.h>
#include <asm/io.h>
 
 
#define KEY_NUMS 3
 
 
irqreturn_t input_key_irq_handler(int irqno, void *devid);	//中断入口
void get_all_child_from_node(void);
 
//设计一个对象出来
struct key_desc{
	char *name;
	int irqno;
	int key_code;
	int gpionum;
	void *reg_base;
	struct device_node *cnp;// 可以随时去获取节点各个信息
};
 
struct key_desc all_key[KEY_NUMS];
 
struct input_dev *inputdev;
 
 
static int __init input_drv_init(void)
{
	printk("-------%s-------------\n", __FUNCTION__);
 
	int ret;
	//分配 input device 对象
	inputdev = input_allocate_device();
	if(NULL == inputdev)
	{
		printk(KERN_ERR "input_allocate_device error\n");
		return -ENOMEM;
	}
 
	//遍历设备节点 并存放到结构体all_key[i]中
	get_all_child_from_node();
 
	//添加设备信息--/sys/class/input/eventx/device/
	inputdev->name = "simple input key";
	inputdev->phys = "key/input/input0";
	inputdev->uniq = "simple key0 for 4412";
	inputdev->id.bustype = BUS_HOST;
	inputdev->id.vendor =0x1234 ;
	inputdev->id.product = 0x8888;
	inputdev->id.version = 0x0001;
 
	//初始化 input device 对象
	__set_bit(EV_KEY,  inputdev->evbit);
 
	int i;
	for(i=0; i<KEY_NUMS; i++)
	{
		//设置keybit，支持哪些按键
		// 按键值从设备设备树
		int code;
		struct device_node *cnp = all_key[i].cnp;
		
		of_property_read_u32(cnp,"key_code", &code);
		__set_bit(code, inputdev->keybit);
		all_key[i].key_code = code; //先记录下来
 
 
		int irqno;
		irqno = irq_of_parse_and_map(cnp, 0);
		all_key[i].irqno = irqno;//先记录下来
 
		char *key_name ;
		of_property_read_string(cnp, "key_name",  &key_name);
		all_key[i].name = key_name;
 
		printk("name = %s, code = %d,irqno = %d\n",
						key_name, code,irqno);	
 
		int irqflags = IRQF_TRIGGER_FALLING|IRQF_TRIGGER_RISING;
		
		ret = request_irq(irqno, input_key_irq_handler, irqflags, 
					key_name, &all_key[i]);
		if(ret != 0)
		{
			printk("request_irq error\n");
			goto err_0;
		}
		
	}
 
 
	//注册 input device 对象
	ret = input_register_device(inputdev);
	if(0 != ret)
	{
		printk(KERN_ERR "input_allocate_device error\n");
		goto err_0;
	}
 
 
	return 0;
 
 
	err_1:
		input_unregister_device(inputdev);
 
	err_0:
		input_free_device(inputdev);
		return ret;
}
 
static void __exit input_drv_exit(void)
{
	printk("-------%s-------------\n", __FUNCTION__);
	int i;
	for(i=0; i<KEY_NUMS; i++)
		free_irq(all_key[i].irqno, &all_key[i]); //释放中断资源
		
	input_unregister_device(inputdev);	//将input device 对象注销
	input_free_device(inputdev);		//释放input device 对象
 
}
 
irqreturn_t  input_key_irq_handler(int irqno, void *devid)
{
	printk("-------%s-------------\n", __FUNCTION__);
 
	//区分不同的按键
	struct key_desc *pdesc = (struct key_desc *)devid;
 
	int gpionum = of_get_named_gpio(pdesc->cnp, "gpio", 0);
	
	
	//直接通过gpio获取按键状态
	int value = gpio_get_value(gpionum);
	
	if(value){//抬起
		
		input_report_key(inputdev, pdesc->key_code, 0);
		input_sync(inputdev);//上报数据结束
			
	}else{
		input_report_key(inputdev, pdesc->key_code, 1);
		input_sync(inputdev);//上报数据结束
	}
 
 
	return IRQ_HANDLED;
 
}
 
 
void get_all_child_from_node(void)
{
	// 获取到设备树中到节点
	struct device_node *np = of_find_node_by_path("/key_int_node");
	if(np){
		printk("find node ok\n");
	}else{
		printk("find node failed\n");
	}
 
	struct device_node *cnp;
	struct device_node *prev = NULL;
 
	int i = 0;
 
	do{
			//获取到子节点
			cnp = of_get_next_child(np, prev);
			if(cnp != NULL){
				all_key[i++].cnp = cnp;//将当前的节点记录下来
			}
 
			prev = cnp; //把当前的设置位prev
 
		}while(of_get_next_child(np, prev) != NULL);
 
}
 
 
module_init(input_drv_init);
module_exit(input_drv_exit);
 
MODULE_LICENSE("GPL");

```

**应用程序**
用户读取设备节点，读取到的是指定的input_event类型的数据包。然后分析键值，并打印键值。

```
//simple_input_test.c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <linux/input.h>
 
int main(void)
{
	int fd;
	int ret;
	struct input_event event;
	
	fd = open("/dev/input/event1", O_RDWR);
	if(fd < 0)
	{
		perror("open");
		exit(1);
	}
 
 
	while(1)
	{
		ret = read(fd, &event, sizeof(struct input_event));
		if(ret < 0)
		{
			perror("read");
			exit(1);
		}
 
		if(event.type == EV_KEY){
			switch(event.code){
				case KEY_POWER:
					if(event.value){ //按下
						printf("__APP_USER__ :  power pressed\n");
 
					}else{
						printf("__APP_USER__ :  power up\n");
					}
					break;
				case KEY_VOLUMEDOWN:
					if(event.value){ //按下
						printf("__APP_USER__ :  KEY_VOLUMEDOWN pressed\n");
 
					}else{
						printf("__APP_USER__ :  KEY_VOLUMEDOWN up\n");
					}
					break;
				case KEY_VOLUMEUP:
					if(event.value){ //按下
						printf("__APP_USER__ :  KEY_VOLUMEUP pressed\n");
 
					}else{
						printf("__APP_USER__ :  KEY_VOLUMEUP up\n");
					}
					break;
	
			}
 
		}
		
	}
 
 
	close(fd);
 
	return 0;
}
```